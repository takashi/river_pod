---
title: テスト
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

中規模から大規模のアプリケーションでは、アプリケーションをテストすることが重要になってきます。

正常にアプリケーションをテストするためには、以下のものが必要です:

- `test/testWidgets` 間ではステートを保存するべきではありません。
  つまり、グローバルステートが存在しないか、すべてのグローバルステートはテストごとにリセットされるべきです。

- プロバイダに特定の状態を強制させるために、モックをするか、求める状態まで操作をすることができる。

それでは、[Riverpod] がそれらをどのようにサポートしてくれるのか、一つずつ見ていきましょう。

## `test`/`testWidgets` 間ではステートを保存してはいけません。

プロバイダは通常、グローバル変数として宣言されているので、そのことが気になったかもしれません。
結局のところ、グローバル変数は長い `setUp`/`tearDown` を必要とし、テストを非常に難しくしています。

しかし、現実はプロバイダはグローバルに宣言されていますが、プロバイダの状態はグローバルではありません。

代わりに、[ProviderContainer] という名前のオブジェクトに保存されています。これは dart のみのコードサンプルで見たことがあるかもしれません。
もしそうでないなら、[ProviderContainer] は [Riverpod] が有効化されているプロジェクトで [ProviderScope] によって暗黙的に作成されていることを知っておいてください。

具体的には、プロバイダを使っている2つの `testWidgets` が、状態を共有しないということです。そのため、`setUp`/`tearDown`は一切必要ありません。

長々とした説明よりも、例があったほうがいいでしょう:

<Tabs
  defaultValue="testWidgets"
  values={[
    { label: 'testWidgets (Flutter)', value: 'testWidgets', },
    { label: 'test (Dart only)', value: 'test', },
  ]}
>
<TabItem value="testWidgets">

```dart
// A Counter implemented and tested using Flutter

// We declared a provider globally, and we will use it in two tests, to see
// if the state correctly resets to `0` between tests.
final counterProvider = StateProvider((ref) => 0);

// Renders the current state and a button that allows incrementing the state
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Consumer(builder: (context, ref, _) {
        final counter = ref.watch(counterProvider);
        return RaisedButton(
          onPressed: () => counter.state++,
          child: Text('${counter.state}'),
        );
      }),
    );
  }
}

void main() {
  testWidgets('update the UI when incrementing the state', (tester) async {
    await tester.pumpWidget(ProviderScope(child: MyApp()));

    // The default value is `0`, as declared in our provider
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Increment the state and re-render
    await tester.tap(find.byType(RaisedButton));
    await tester.pump();

    // The state have properly incremented
    expect(find.text('1'), findsOneWidget);
    expect(find.text('0'), findsNothing);
  });

  testWidgets('the counter state is not shared between tests', (tester) async {
    await tester.pumpWidget(ProviderScope(child: MyApp()));

    // The state is `0` once again, with no tearDown/setUp needed
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);
  });
}
```

</TabItem>
<TabItem value="test">

```dart
// A Counter implemented and tested with Dart only (no dependency on Flutter)

// We declared a provider globally, and we will use it in two tests, to see
// if the state correctly resets to `0` between tests.
final counterProvider = StateProvider((ref) => 0);

// Using mockito to keep track of when a provider notify its listeners
class Listener extends Mock {
  void call(int value);
}

void main() {
  test('defaults to 0 and notify listeners when value changes', () {
    // An object that will allow us to read providers
    // Do not share this between tests.
    final container = ProviderContainer();
    addTearDown(container.dispose);
    final listener = Listener();

    // Observe a provider and spy the changes.
    container.listen<StateController<int>>(
      counterProvider,
      didChange: (sub) => listener(sub.read().state),
    );

    // the listener is called immediatly with 0, the default value
    verify(listener(0)).called(1);
    verifyNoMoreInteractions(listener);

    // We increment the value
    container.read(counterProvider).state++;

    // The listener was called again, but with 1 this time
    verify(listener(1)).called(1);
    verifyNoMoreInteractions(listener);
  });

  test('the counter state is not shared between tests', () {
    // We use a different ProviderContainer to read our provider.
    // This unsure that no state is reused between tests
    final container = ProviderContainer();
    addTearDown(container.dispose);
    final listener = Listener();

    container.listen<StateController<int>>(
      counterProvider,
      didChange: (sub) => listener(sub.read().state),
    );

    // The new test correcly uses the default value: 0
    verify(listener(0)).called(1);
    verifyNoMoreInteractions(listener);
  });
}
```

</TabItem>
</Tabs>

見ての通り、 `counterProvider` はグローバルに宣言されていますが、ステートはテスト間で共有されていません。
このように、テストは完全に分離された状態で実行されるため、異なる順序で実行された場合にテストの動作が変わってしまうことを心配する必要はありません。

## テスト中にプロバイダの挙動を上書きする

実世界のアプリケーションは、次のようなオブジェクトを持つと思います:

- 型安全で、HTTP リクエストを行うシンプルなAPIを持った、 `Repository` クラス

- アプリケーションの状態を管理し、さまざまな要因に応じて HTTP リクエストを実行するために `Repository` を使用することができるオブジェクト。
  これはおそらく `ChangeNotifier`、`Bloc`、またはプロバイダです。

[Riverpod] を利用すると、これはこのように示すことができます:

```dart
class Repository {
  Future<List<Todo>> fetchTodos() async {}
}

// We expose our instance of Repository in a provider
final repositoryProvider = Provider((ref) => Repository());

/// The list of todos. Here, we are simply fetching them from the server using
/// [Repository] and doing nothing else.
final todoListProvider = FutureProvider((ref) async {
  // Obtains the Repository instance
  final repository = ref.read(repositoryProvider);

  // Fetch the todos and expose them to the UI.
  return repository.fetchTodos();
});
```

このような状況で、ユニットテストやウィジェットテストを行う際には通常、`Repository` のインスタンスを、実際のHTTPリクエストの代わりに、あらかじめ定義されたレスポンスを返す偽の実装に置き換えたいと思うでしょう。

そして `todoListProvider` か、それと同等のものが `Repository` のモックが実装されたものを利用してほしいはずです。

これを実現するために、[ProviderScope]/[ProviderContainer] の `override` パラメータを `repositoryProvider` の挙動を上書きするために利用できます。

<Tabs
  defaultValue="ProviderScope"
  values={[
    { label: 'ProviderScope (Flutter)', value: 'ProviderScope', },
    { label: 'ProviderContainer (Dart only)', value: 'ProviderContainer', },
  ]}
>
<TabItem value="ProviderScope">

```dart {7}
testWidgets('override repositoryProvider', (tester) async {
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        // Override the behavior of repositoryProvider to return
        // FakeRepository instead of Repository.
        repositoryProvider.overrideWithProvider(Provider((ref) => FakeRepository()))
        // We do not have to override `todoListProvider`, it will automatically
        // use the overriden repositoryProvider
      ],
      child: MyApp(),
    ),
  );
}
```

</TabItem>
<TabItem value="ProviderContainer">

```dart {6}
test('override repositoryProvider', () async {
  final container = ProviderContainer(
    overrides: [
      // Override the behavior of repositoryProvider to return
      // FakeRepository instead of Repository.
      repositoryProvider.overrideWithProvider(Provider((ref) => FakeRepository()))
      // We do not have to override `todoListProvider`, it will automatically
      // use the overriden repositoryProvider
    ],
  );

  // The first read if the loading state
  expect(
    container.read(todoListProvider),
    const AsyncValue<List<Todo>>.loading(),
  );

  /// Wait for the request to finish
  await Future<void>.value();

  // Exposes the data fetched
  expect(container.read(todoListProvider).data.value, [
    isA<Todo>()
        .having((s) => s.id, 'id', '42')
        .having((s) => s.label, 'label', 'Hello world')
        .having((s) => s.completed, 'completed', false),
  ]);
});
```

</TabItem>
</Tabs>

ハイライトされたコードの通り、[ProviderScope]/[ProviderContainer] はプロバイダの実装を別の挙動で置き換えることができます。

:::info
いくつかのプロバイダは簡略化された挙動の上書きの手段を持っています。
例として [FutureProvider] は `AsyncValue` を利用して上書きすることができます。

````dart
final todoListProvider = FutureProvider((ref) async => <Todo>[]);
// ...
ProviderScope(
  overrides: [
    /// Allows overriding a FutureProvider to return a fixed value
    todoListProvider.debugOverrideWithValue(
      AsyncValue.data([Todo(id: '42', label: 'Hello', completed: true)]),
    ),
  ],
  child: MyApp(),
);
:::



## 完全なウィジェットテストの例

最後に、今回の Flutter のテストの全コードを紹介します。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';

class Repository {
  Future<List<Todo>> fetchTodos() async {}
}

class Todo {
  Todo({
    required this.id,
    required this.label,
    required this.completed,
  });

  final String id;
  final String label;
  final bool completed;
}

// We expose our instance of Repository in a provider
final repositoryProvider = Provider((ref) => Repository());

/// The list of todos. Here, we are simply fetching them from the server using
/// [Repository] and doing nothing else.
final todoListProvider = FutureProvider((ref) async {
  // Obtains the Repository instance
  final repository = ref.read(repositoryProvider);

  // Fetch the todos and expose them to the UI.
  return repository.fetchTodos();
});

/// A mocked implementation of Repository that returns a pre-defined list of todos
class FakeRepository implements Repository {
  @override
  Future<List<Todo>> fetchTodos() async {
    return [
      Todo(id: '42', label: 'Hello world', completed: false),
    ];
  }
}

class TodoItem extends StatelessWidget {
  const TodoItem({Key? key, required this.todo}) : super(key: key);
  final Todo todo;
  @override
  Widget build(BuildContext context) {
    return Text(todo.label);
  }
}

void main() {
  testWidgets('override repositoryProvider', (tester) async {
    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          repositoryProvider.overrideWithProvider(Provider((ref) => FakeRepository()))
        ],
        // Our application, which will read from todoListProvider to display the todo-list.
        // You may extract this into a MyApp widget
        child: MaterialApp(
          home: Scaffold(
            body: Consumer(builder: (context, ref, _) {
              final todos = ref.watch(todoListProvider);
              // The list of todos is loading or in error
              if (todos.data == null) {
                return const CircularProgressIndicator();
              }
              return ListView(
                children: [
                  for (final todo in todos.data.value) TodoItem(todo: todo)
                ],
              );
            }),
          ),
        ),
      ),
    );

    // The first frame is a loading state.
    expect(find.byType(CircularProgressIndicator), findsOneWidget);

    // Re-render. TodoListProvider should have finished fetching the todos by now
    await tester.pump();

    // No-longer loading
    expect(find.byType(CircularProgressIndicator), findsNothing);

    // Rendered one TodoItem with the data returned by FakeRepository
    expect(tester.widgetList(find.byType(TodoItem)), [
      isA<TodoItem>()
          .having((s) => s.todo.id, 'todo.id', '42')
          .having((s) => s.todo.label, 'todo.label', 'Hello world')
          .having((s) => s.todo.completed, 'todo.completed', false),
    ]);
  });
}
````

[riverpod]: https://github.com/rrousselgit/river_pod
[providerscope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[providercontainer]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[futureprovider]: https://pub.dev/documentation/riverpod/latest/riverpod/FutureProvider-class.html
[zone]: https://api.flutter.dev/flutter/dart-async/Zone-class.html
